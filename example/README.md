# Example usage of Wayland-Scribe
The examples are dummy examples, and do not do anything useful. They do not compile, and are not meant to be compiled. These examples are a simple
demo of how wayland-scribe can be used in your projects.


## Server
A simple example demonstrating method 1.

A sample meson.build file is included to demonstrate the usage of wayland-scanner to generate the c code. This meson file is neither complete,
nor does anything useful.


### What is Method 1
Here, we generate the C++ code using wayland-scribe. Once the code is generated, wayland-scribe is no longer required. The source and the header
files can be assimilated into your source tree. You'll not need wayland-scribe until the protocol changes.


### How to generate the C++ code
The command to generate the C++ code is extremely simple:
```sh
wayland-scribe --server my-protocol-name.xml
```


### What is generated?
Two files are generated, namely,
1. Source or cpp file: `<my-protocol-name>-server.cpp` (in our example, `hello-world-server.cpp`)
2. Header or hpp file: `<my-protocol-name>-server.hpp` (in our example, `hello-world-server.hpp`)


### What changes do I need to make to these files?
The header file can be used as is, without any modifications. One single change needs to be done to the source file: Modify line 144-145 of the generated CPP.
```C++
void Wayland::Server::Greeter::sayHello(Resource *, const std::string &name) {
    sendHello( "Aloha, " + name );
}
```


### What else is needed to compile these files?
1. C server-side code. <br>
   By default, the files generated by wayland-scribe expect the c-header to be named as: `<my-protocol-name>-server.h`. For a protocol named `hello_world`, the c-header should be named as `hello-world-server.h`, which can be generated with `wayland-scanner` using the incantation:
    ```sh
    wayland-scanner server-header hello-world.xml hello-world-server.h
    ```
2. C private/public code. <br>
   In addition to the c header code, you'll also need the private/public code generated by wayland-scanner. It can be generated using the incantation:
    ```sh
    wayland-scanner private-code hello-world.xml hello-world-server.c
    ```


## Client
A simple example demonstrating method 2.


### What is Method 2
Here, we expect the downstream user to have wayland-scribe, and generate the C++ code by themselves.


### How to generate the C++ code
The command to generate the C++ code is extremely simple:
```sh
wayland-scribe --client my-protocol-name.xml
```


### What is generated?
Two files are generated, namely,
1. Source or cpp file: `<my-protocol-name>-client.cpp` (in our example, `hello-world-client.cpp`)
2. Header or hpp file: `<my-protocol-name>-client.hpp` (in our example, `hello-world-client.hpp`)


### What changes do I need to make to these files?
Nothing. These are dynamically generated by the user as and when needed.


### What else is needed to compile these files?
1. C server-side code. <br>
   By default, the files generated by wayland-scribe expect the c-header to be named as: `<my-protocol-name>-server.h`. For a protocol named `hello_world`, the c-header should be named as `hello-world-server.h`, which can be generated with `wayland-scanner` using the incantation:
    ```sh
    wayland-scanner server-header hello-world.xml hello-world-server.h
    ```
2. C private/public code. <br>
   In addition to the c header code, you'll also need the private/public code generated by wayland-scanner. It can be generated using the incantation:
    ```sh
    wayland-scanner private-code hello-world.xml hello-world-server.c
    ```

3. C++ Subclass of the generated C++ class.
   We need to ship a simple C++ class that derives from the class generated by wayland-scribe.
   The virtual methods need t obe overridden to pr0vide our implementation. In the case of hello-world, it's an extremely simple class:
   ```c++
   #include <iostream>
   #include <hello-world-client.hpp>

   class MyHelloWord: public Wayland::Client::Greeter {
       protected:
           void hello(const std::string &greeting) {
               std::cout << "The server says: " << greeting << std::endl;
           };
   }
   ```

## Should I use method 1 or method 2, or xan I mix and match methods 1 and 2?
This decision is entirely left to you!! However, a simple rule of thumb to make your life easier.
1. If this is a stable protocol, and is unlikely to change in the next couple of years in any major way, (say, for example, the core wayland protocol, or the linxu-dmabuf protocol), you can use method 1. It removes the number of dependencies on your project.

2. If you are working with a new protocol that is expected to see some rapid evolutions and large changes, it is beneficial to use method 2. While number of changes that need to be made will remain the same, the strain of searching the correct place and functions in the large cpp source file will reduce significantly.

3. If you decide to mix and match, you get the best of both worlds. Generate the CPP source/header. Make the changes in the derived class. Ship them both!! Even with a rapidly evolving protocol, you'll be doing the same amount of work as in method 2, and get the advantage of method 1.
